<div class="streams-container">
  <h1>RxJS Operators in Angular</h1>

  <!-- Introduction -->
  <div class="section">
    <h2>What Are RxJS Operators?</h2>
    <p>
      Operators are <strong>pure functions</strong> that transform, filter, or
      combine observables. They allow you to manipulate data streams in a
      declarative way.
    </p>
    Common operators:
    <ul>
      <li><code>map</code>: Transform each emitted value.</li>
      <li><code>filter</code>: Only emit values that meet a condition.</li>
      <li>
        <code>debounceTime</code>: Delay emissions until a period of inactivity.
      </li>
      <li><code>take</code>: Only emit the first N values.</li>
      <li>
        <code>tap</code>: Perform side effects without modifying the stream.
      </li>
    </ul>
  </div>

  <!-- Interval Example -->
  <div class="section">
    <h2>Example 1: Interval Stream with Operators</h2>
    <p>
      This example uses <code>interval</code> to emit values every second and
      applies <code>map</code>, <code>filter</code>, and
      <code>take</code> operators.
    </p>

    <div class="controls">
      <button (click)="startIntervalStream()" [disabled]="isIntervalRunning">
        Start Stream
      </button>
      <button (click)="stopIntervalStream()" [disabled]="!isIntervalRunning">
        Stop Stream
      </button>
      <button (click)="dangerousLeakingInterval()" class="danger-button">
        ⚠️ Leaking Stream (Demo)
      </button>
    </div>

    <div class="stream-container">
      <!-- Main output -->
      <div class="output">
        <h3>Operator Pipeline:</h3>
        <ol>
          <li>
            <code>interval(1000)</code>: Emits 0, 1, 2, 3... every second.
          </li>
          <li>
            <code>tap</code>: Logs raw values →
            <strong>{{ intervalValues$ | async }}</strong>
          </li>
          <li>
            <code>map(value => value * 2)</code>: Doubles each value →
            <strong>{{ mappedValues$ | async }}</strong>
          </li>
          <li>
            <code>filter(value => value % 3 === 0)</code>: Keeps multiples of 3
            →
            <strong>{{ filteredValues$ | async }}</strong>
          </li>
          <li>
            <code>take(10)</code>: Takes first 10 values →
            <strong>{{ takenValues$ | async }}</strong>
          </li>
        </ol>
      </div>

      <!-- Leaking Stream Output -->
      <div class="leaking-output">
        <h3>⚠️ Leaking Stream Output:</h3>
        <div class="leaking-values">
          @for (value of unsafeStreamValues; track value) {
            <div>{{ value }}</div>
          }
        </div>
      </div>
    </div>
  </div>

  <!-- Search Example -->
  <div class="section">
    <h2>Example 2: Search with Debounce</h2>
    <p>
      This example uses <code>debounceTime</code> and <code>map</code> to filter
      a list of users based on a search term. The search only triggers after
      500ms of inactivity.
    </p>

    <div class="search-container">
      <input
        type="text"
        placeholder="Search users..."
        class="search-input"
        (valueChange)="startSearch()"
      />
      @if (searchResults.length > 0) {
        <div class="search-results">
          <h3>Results:</h3>
          <ul>
            @for (result of searchResults$ | async; track result) {
              <li>{{ result }}</li>
            }
          </ul>
        </div>
      }
      @if (searchResults.length === 0) {
        <div class="no-results">No users found.</div>
      }
    </div>
  </div>

  <!-- Mouse Move Example -->
  <div class="section">
    <h2>Example 3: Mouse Move with Throttle</h2>
    <p>
      This example uses <code>fromEvent</code> and <code>debounceTime</code> to
      track mouse movements and reduce the frequency of emissions.
    </p>

    <div class="controls">
      <button
        (click)="startMouseMoveStream()"
        [disabled]="mouseMoveSubscription !== null"
      >
        Start Tracking Mouse
      </button>
      <button
        (click)="stopMouseMoveStream()"
        [disabled]="mouseMoveSubscription === null"
      >
        Stop Tracking Mouse
      </button>
    </div>

    <div class="output">
      <h3>Mouse Positions (throttled):</h3>
      @if (mouseMoves.length > 0) {
        <div>
          <ul>
            @for (move of mouseMoves; track move) {
              <li>
                ({{ move.x | number: "1.0-0" }}, {{ move.y | number: "1.0-0" }})
              </li>
            }
          </ul>
        </div>
      }
      @if (mouseMoves.length === 0) {
        <div class="no-results">No mouse movements tracked yet.</div>
      }
    </div>
  </div>

  <!-- Custom Data Stream Example -->
  <div class="section">
    <h2>Example 4: Custom Data Stream with Map</h2>
    <p>
      This example uses <code>of</code> and <code>map</code> to transform an
      array of user objects into formatted strings.
    </p>

    <div class="controls">
      <button (click)="startUserStream()">Transform Users</button>
    </div>

    <div class="output">
      <h3>Transformed Users:</h3>
      @if (userStreamValues.length > 0) {
        <div>
          <ul>
            @for (user of userStreamValues$ | async; track user) {
              <li>{{ user }}</li>
            }
          </ul>
        </div>
      }
      @if (userStreamValues.length === 0) {
        <div class="no-results">No users transformed yet.</div>
      }
    </div>
  </div>

  <!-- RxJS vs. Kotlin vs. Java -->
  <div class="section">
    <h2>RxJS vs. Kotlin vs. Java</h2>
    <p>
      In Kotlin, you might use <strong>coroutines</strong> or
      <strong>Flow</strong> for async programming. In Java, you might use
      <strong>CompletableFuture</strong>, <strong>RxJava</strong>, or the
      <strong>reactive-streams</strong> API. RxJS is similar but uses
      <strong>Observables</strong> and <strong>Subscriptions</strong>.
    </p>
    <table>
      <thead>
        <tr>
          <th>Concept</th>
          <th>RxJS (Angular)</th>
          <th>Kotlin</th>
          <th>Java (Project Reactor)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Async Stream</td>
          <td><code>Observable</code></td>
          <td><code>Flow</code></td>
          <td><code>Flux/Mono</code></td>
        </tr>
        <tr>
          <td>Transformation</td>
          <td><code>map</code>, <code>filter</code></td>
          <td><code>map</code>, <code>filter</code></td>
          <td><code>map</code>, <code>filter</code></td>
        </tr>
        <tr>
          <td>Subscription</td>
          <td><code>subscribe()</code></td>
          <td><code>collect()</code> or <code>launch</code></td>
          <td><code>subscribe()</code></td>
        </tr>
        <tr>
          <td>Cleanup</td>
          <td><code>unsubscribe()</code></td>
          <td>Automatic with coroutine scope</td>
          <td>Automatic with <code>Flux/Mono</code></td>
        </tr>
        <tr>
          <td>Error Handling</td>
          <td><code>catchError</code> in <code>pipe</code></td>
          <td>
            <code>catch</code> (Flow) or <code>try-catch</code> (coroutines)
          </td>
          <td><code>onErrorResume</code></td>
        </tr>
        <tr>
          <td>Threading</td>
          <td>
            Handled by <code>asyncScheduler</code> or
            <code>queueScheduler</code>
          </td>
          <td>
            <code>Dispatchers.IO</code> or <code>Dispatchers.Default</code>
          </td>
          <td><code>subscribeOn</code>/<code>publishOn</code></td>
        </tr>
        <tr>
          <td>Backpressure</td>
          <td>
            Not built-in (use operators like <code>buffer</code> or
            <code>throttle</code>)
          </td>
          <td>Built-in with <code>Flow</code></td>
          <td>Built-in with <code>Flux</code>/<code>Mono</code></td>
        </tr>
        <tr>
          <td>Common Use Case</td>
          <td>Frontend async operations (e.g., HTTP, user input)</td>
          <td>Android/Kotlin backend async operations</td>
          <td>Backend services, Spring WebFlux</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- Best Practices -->
  <div class="section">
    <h2>Best Practices with Operators</h2>
    <ul>
      <li>
        <strong>Chain operators</strong>: Use the <code>pipe</code> method to
        chain operators in a readable way.
      </li>
      <li>
        <strong>Avoid side effects in operators</strong>: Use
        <code>tap</code> for side effects like logging.
      </li>
      <li>
        <strong>Unsubscribe</strong>: Always clean up subscriptions to avoid
        memory leaks.
      </li>
      <li>
        <strong>Use async pipe in templates</strong>: Automatically handles
        subscriptions in Angular templates.
      </li>
      <li>
        <strong>Error handling</strong>: Provide an <code>error</code> callback
        in <code>subscribe</code>.
      </li>
    </ul>
  </div>
</div>
